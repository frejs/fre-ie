{"version":3,"file":"freie.js","sources":["../polyfil.js","../node_modules/fre/dist/fre.esm.js"],"sourcesContent":["!window.addEventListener &&\r\n  (function (WindowPrototype, DocumentPrototype, ElementPrototype, addEventListener, removeEventListener, dispatchEvent, registry) {\r\n    WindowPrototype[addEventListener] = DocumentPrototype[addEventListener] = ElementPrototype[addEventListener] = function (type, listener) {\r\n      var target = this\r\n\r\n      registry.unshift([\r\n        target,\r\n        type,\r\n        listener,\r\n        function (event) {\r\n          event.currentTarget = target\r\n          event.preventDefault = function () {\r\n            event.returnValue = false\r\n          }\r\n          event.stopPropagation = function () {\r\n            event.cancelBubble = true\r\n          }\r\n          event.target = event.srcElement || target\r\n\r\n          listener.call(target, event)\r\n        },\r\n      ])\r\n\r\n      this.attachEvent('on' + type, registry[0][3])\r\n    }\r\n\r\n    WindowPrototype[removeEventListener] = DocumentPrototype[removeEventListener] = ElementPrototype[removeEventListener] = function (\r\n      type,\r\n      listener\r\n    ) {\r\n      for (var index = 0, register; (register = registry[index]); ++index) {\r\n        if (register[0] == this && register[1] == type && register[2] == listener) {\r\n          return this.detachEvent('on' + type, registry.splice(index, 1)[0][3])\r\n        }\r\n      }\r\n    }\r\n\r\n    WindowPrototype[dispatchEvent] = DocumentPrototype[dispatchEvent] = ElementPrototype[dispatchEvent] = function (eventObject) {\r\n      return this.fireEvent('on' + eventObject.type, eventObject)\r\n    }\r\n  })(Window.prototype, HTMLDocument.prototype, Element.prototype, 'addEventListener', 'removeEventListener', 'dispatchEvent', [])\r\n\r\ndocument.createTextNode = function (data) {\r\n  const text = document.createElement('x-text')\r\n  text.innerText = data\r\n\r\n  return text\r\n}\r\n","const isArr = Array.isArray;\r\nconst isStr = s => typeof s === 'string' || typeof s === 'number';\r\nconst MEMO = 0;\r\n\r\nfunction h(type, attrs, ...args) {\r\n  let props = attrs || {};\r\n  let key = props.key || null;\r\n  let ref = props.ref || null;\r\n  let children = [];\r\n\r\n  for (let i = 0; i < args.length; i++) {\r\n    let vnode = args[i];\r\n    if (vnode == null || vnode === true || vnode === false) ; else if (isStr(vnode)) {\r\n      children.push(createText(vnode));\r\n    } else {\r\n      while (isArr(vnode) && vnode.some(v => isArr(v))) {\r\n        vnode = [].concat(...vnode);\r\n      }\r\n      children.push(vnode);\r\n    }\r\n  }\r\n\r\n  if (children.length) {\r\n    props.children = children.length === 1 ? children[0] : children;\r\n  }\r\n\r\n  delete props.key;\r\n  delete props.ref;\r\n\r\n  return { type, props, key, ref }\r\n}\r\n\r\nfunction createText(vnode) {\r\n  return { type: 'text', props: { nodeValue: vnode } }\r\n}\r\n\r\nfunction Fragment(props) {\r\n  return props.children\r\n}\r\n\r\nfunction memo(fn) {\r\n  fn.tag = MEMO;\r\n  return fn\r\n}\n\nfunction updateElement(dom, oldProps, newProps) {\r\n  for (let name in { ...oldProps, ...newProps }) {\r\n    let oldValue = oldProps[name];\r\n    let newValue = newProps[name];\r\n\r\n    if (oldValue == newValue || name === 'children') ; else if (name === 'style') {\r\n      for (const k in { ...oldValue, ...newValue }) {\r\n        if (!(oldValue && newValue && oldValue[k] === newValue[k])) {\r\n          dom[name][k] = (newValue && newValue[k]) || '';\r\n        }\r\n      }\r\n    } else if (name[0] === 'o' && name[1] === 'n') {\r\n      name = name.slice(2).toLowerCase();\r\n      if (oldValue) dom.removeEventListener(name, oldValue);\r\n      dom.addEventListener(name, newValue);\r\n    } else if (name in dom && !(dom instanceof SVGElement)) {\r\n      dom[name] = newValue == null ? '' : newValue;\r\n    } else if (newValue == null || newValue === false) {\r\n      dom.removeAttribute(name);\r\n    } else {\r\n      dom.setAttribute(name, newValue);\r\n    }\r\n  }\r\n}\r\n\r\nfunction createElement(fiber) {\r\n  const dom =\r\n    fiber.type === 'text'\r\n      ? document.createTextNode('')\r\n      : fiber.tag === SVG\r\n      ? document.createElementNS('http://www.w3.org/2000/svg', fiber.type)\r\n      : document.createElement(fiber.type);\r\n  updateElement(dom, {}, fiber.props);\r\n  return dom\r\n}\n\nlet cursor = 0;\r\n\r\nfunction resetCursor() {\r\n  cursor = 0;\r\n}\r\n\r\nfunction useState(initState) {\r\n  return useReducer(null, initState)\r\n}\r\n\r\nfunction useReducer(reducer, initState) {\r\n  const [hook, current] = getHook(cursor++);\r\n  const setter = value => {\r\n    let newValue = reducer\r\n      ? reducer(hook[0], value)\r\n      : isFn(value)\r\n      ? value(hook[0])\r\n      : value;\r\n    if (newValue !== hook[0]) {\r\n      hook[0] = newValue;\r\n      scheduleWork(current);\r\n    }\r\n  };\r\n\r\n  if (hook.length) {\r\n    return [hook[0], setter]\r\n  } else {\r\n    hook[0] = initState;\r\n    return [initState, setter]\r\n  }\r\n}\r\n\r\nfunction useEffect(cb, deps) {\r\n  return effectImpl(cb, deps, 'effect')\r\n}\r\n\r\nfunction useLayout(cb, deps) {\r\n  return effectImpl(cb, deps, 'layout')\r\n}\r\n\r\nfunction effectImpl(cb, deps, key) {\r\n  let [hook, current] = getHook(cursor++);\r\n  if (isChanged(hook[1], deps)) {\r\n    hook[0] = useCallback(cb, deps);\r\n    hook[1] = deps;\r\n    current.hooks[key].push(hook);\r\n  }\r\n}\r\n\r\nfunction useMemo(cb, deps) {\r\n  let hook = getHook(cursor++)[0];\r\n  if (isChanged(hook[1], deps)) {\r\n    hook[1] = deps;\r\n    return (hook[0] = cb())\r\n  }\r\n  return hook[0]\r\n}\r\n\r\nfunction useCallback(cb, deps) {\r\n  return useMemo(() => cb, deps)\r\n}\r\n\r\nfunction useRef(current) {\r\n  return useMemo(() => ({ current }), [])\r\n}\r\n\r\nfunction getHook(cursor) {\r\n  const current = getCurrentFiber();\r\n  let hooks =\r\n    current.hooks || (current.hooks = { list: [], effect: [], layout: [] });\r\n  if (cursor >= hooks.list.length) {\r\n    hooks.list.push([]);\r\n  }\r\n  return [hooks.list[cursor], current]\r\n}\r\n\r\nfunction isChanged(a, b) {\r\n  return !a || b.some((arg, index) => arg !== a[index])\r\n}\n\nfunction push(heap, node) {\r\n  const i = heap.length;\r\n  heap.push(node);\r\n  siftUp(heap, node, i);\r\n}\r\n\r\nfunction pop(heap) {\r\n  const first = heap[0];\r\n  if (!first) return null\r\n  const last = heap.pop();\r\n  if (last !== first) {\r\n    heap[0] = last;\r\n    siftDown(heap, last, 0);\r\n  }\r\n  return first\r\n}\r\n\r\nfunction siftUp(heap, node, i) {\r\n  while (i > 0) {\r\n    const pi = (i - 1) >>> 1;\r\n    const parent = heap[pi];\r\n    if (cmp(parent, node) <= 0) return\r\n    heap[pi] = node;\r\n    heap[i] = parent;\r\n    i = pi;\r\n  }\r\n}\r\n\r\nfunction siftDown(heap, node, i) {\r\n  for (;;) {\r\n    const li = i * 2 + 1;\r\n    const left = heap[li];\r\n    if (li >= heap.length) return\r\n    const ri = li + 1;\r\n    const right = heap[ri];\r\n    const ci = ri < heap.length && cmp(right, left) < 0 ? ri : li;\r\n    const child = heap[ci];\r\n    if (cmp(child, node) > 0) return\r\n    heap[ci] = node;\r\n    heap[i] = child;\r\n    i = ci;\r\n  }\r\n}\r\n\r\nfunction cmp(a, b) {\r\n  return a.dueTime - b.dueTime\r\n}\r\n\r\nfunction peek(heap) {\r\n  return heap[0] || null\r\n}\n\nlet taskQueue = [];\r\nlet currentCallback = null;\r\nlet frameDeadline = 0;\r\nconst frameLength = 1000 / 60;\r\n\r\nfunction scheduleCallback(callback) {\r\n  const currentTime = getTime();\r\n  const startTime = currentTime;\r\n  const timeout = 3000;\r\n  const dueTime = startTime + timeout;\r\n\r\n  let newTask = {\r\n    callback,\r\n    startTime,\r\n    dueTime\r\n  };\r\n\r\n  push(taskQueue, newTask);\r\n  currentCallback = flush;\r\n  planWork();\r\n}\r\n\r\nfunction flush(iniTime) {\r\n  let currentTime = iniTime;\r\n  let currentTask = peek(taskQueue);\r\n\r\n  while (currentTask) {\r\n    const didout = currentTask.dueTime <= currentTime;\r\n    if (!didout && shouldYeild()) break\r\n\r\n    let callback = currentTask.callback;\r\n    currentTask.callback = null;\r\n\r\n    let next = callback(didout);\r\n    next ? (currentTask.callback = next) : pop(taskQueue);\r\n\r\n    currentTask = peek(taskQueue);\r\n    currentTime = getTime();\r\n  }\r\n\r\n  return !!currentTask\r\n}\r\n\r\nfunction flushWork() {\r\n  if (currentCallback) {\r\n    let currentTime = getTime();\r\n    frameDeadline = currentTime + frameLength;\r\n    let more = currentCallback(currentTime);\r\n    more ? planWork() : (currentCallback = null);\r\n  }\r\n}\r\n\r\nconst planWork = (() => {\r\n  if (typeof MessageChannel !== 'undefined') {\r\n    const { port1, port2 } = new MessageChannel();\r\n    port1.onmessage = flushWork;\r\n    return cb => (cb ? requestAnimationFrame(cb) : port2.postMessage(null))\r\n  }\r\n  return cb => setTimeout(cb || flushWork)\r\n})();\r\n\r\nfunction shouldYeild() {\r\n  return getTime() >= frameDeadline\r\n}\r\n\r\nconst getTime = () => performance.now();\n\nconst NOWORK = 0;\r\nconst PLACE = 1;\r\nconst UPDATE = 2;\r\nconst DELETE = 3;\r\n\r\nconst SVG = 4;\r\n\r\nlet preCommit = null;\r\nlet currentFiber = null;\r\nlet WIP = null;\r\nlet updateQueue = [];\r\nlet commitQueue = [];\r\n\r\nfunction render(vnode, node, done) {\r\n  let rootFiber = {\r\n    node,\r\n    props: { children: vnode },\r\n    done\r\n  };\r\n  scheduleWork(rootFiber);\r\n}\r\n\r\nfunction scheduleWork(fiber) {\r\n  if (!fiber.dirty && (fiber.dirty = true)) {\r\n    updateQueue.push(fiber);\r\n  }\r\n  scheduleCallback(reconcileWork);\r\n}\r\n\r\nfunction reconcileWork(didout) {\r\n  if (!WIP) WIP = updateQueue.shift();\r\n  while (WIP && (!shouldYeild() || didout)) {\r\n    WIP = reconcile(WIP);\r\n  }\r\n  if (!didout && WIP) {\r\n    return reconcileWork.bind(null)\r\n  }\r\n  if (preCommit) commitWork(preCommit);\r\n  return null\r\n}\r\n\r\nfunction reconcile(WIP) {\r\n  WIP.parentNode = getParentNode(WIP);\r\n  isFn(WIP.type) ? updateHOOK(WIP) : updateHost(WIP);\r\n  WIP.dirty = WIP.dirty ? false : 0;\r\n  WIP.oldProps = WIP.props;\r\n  commitQueue.push(WIP);\r\n\r\n  if (WIP.child) return WIP.child\r\n  while (WIP) {\r\n    if (!preCommit && WIP.dirty === false) {\r\n      preCommit = WIP;\r\n      return null\r\n    }\r\n    if (WIP.sibling) {\r\n      return WIP.sibling\r\n    }\r\n    WIP = WIP.parent;\r\n  }\r\n}\r\n\r\nfunction updateHOOK(WIP) {\r\n  if (\r\n    WIP.type.tag === MEMO &&\r\n    WIP.dirty == 0 &&\r\n    !shouldUpdate(WIP.oldProps, WIP.props)\r\n  ) {\r\n    cloneChildren(WIP);\r\n    return\r\n  }\r\n  currentFiber = WIP;\r\n  WIP.type.fiber = WIP;\r\n  resetCursor();\r\n  let children = WIP.type(WIP.props);\r\n  if (isStr(children)) {\r\n    children = createText(children);\r\n  }\r\n  reconcileChildren(WIP, children);\r\n}\r\n\r\nfunction updateHost(WIP) {\r\n  if (!WIP.node) {\r\n    if (WIP.type === 'svg') WIP.tag = SVG;\r\n    WIP.node = createElement(WIP);\r\n  }\r\n  let p = WIP.parentNode || {};\r\n  WIP.insertPoint = p.last || null;\r\n  p.last = WIP;\r\n  WIP.node.last = null;\r\n  reconcileChildren(WIP, WIP.props.children);\r\n}\r\n\r\nfunction getParentNode(fiber) {\r\n  while ((fiber = fiber.parent)) {\r\n    if (!isFn(fiber.type)) return fiber.node\r\n  }\r\n}\r\n\r\nfunction reconcileChildren(WIP, children) {\r\n  if (!children) return\r\n  delete WIP.child;\r\n  const oldFibers = WIP.kids;\r\n  const newFibers = (WIP.kids = hashfy(children));\r\n\r\n  let reused = {};\r\n\r\n  for (const k in oldFibers) {\r\n    let newFiber = newFibers[k];\r\n    let oldFiber = oldFibers[k];\r\n\r\n    if (newFiber && newFiber.type === oldFiber.type) {\r\n      reused[k] = oldFiber;\r\n    } else {\r\n      oldFiber.op = DELETE;\r\n      commitQueue.push(oldFiber);\r\n    }\r\n  }\r\n\r\n  let prevFiber = null;\r\n  let alternate = null;\r\n\r\n  for (const k in newFibers) {\r\n    let newFiber = newFibers[k];\r\n    let oldFiber = reused[k];\r\n\r\n    if (oldFiber) {\r\n      alternate = createFiber(oldFiber, UPDATE);\r\n      newFiber.op = UPDATE;\r\n      newFiber = { ...alternate, ...newFiber };\r\n      newFiber.lastProps = alternate.props;\r\n      if (shouldPlace(newFiber)) {\r\n        newFiber.op = PLACE;\r\n      }\r\n    } else {\r\n      newFiber = createFiber(newFiber, PLACE);\r\n    }\r\n\r\n    newFibers[k] = newFiber;\r\n    newFiber.parent = WIP;\r\n\r\n    if (prevFiber) {\r\n      prevFiber.sibling = newFiber;\r\n    } else {\r\n      if (WIP.tag === SVG) newFiber.tag = SVG;\r\n      WIP.child = newFiber;\r\n    }\r\n    prevFiber = newFiber;\r\n  }\r\n\r\n  if (prevFiber) prevFiber.sibling = null;\r\n}\r\n\r\nfunction cloneChildren(fiber) {\r\n  if (!fiber.child) return\r\n  let child = fiber.child;\r\n  let newChild = child;\r\n  newChild.op = NOWORK;\r\n  fiber.child = newChild;\r\n  newChild.parent = fiber;\r\n  newChild.sibling = null;\r\n}\r\n\r\nfunction shouldUpdate(a, b) {\r\n  for (let i in a) if (!(i in b)) return true\r\n  for (let i in b) if (a[i] !== b[i]) return true\r\n  return false\r\n}\r\n\r\nfunction shouldPlace(fiber) {\r\n  let p = fiber.parent;\r\n  if (isFn(p.type)) return p.key && !p.dirty\r\n  return fiber.key\r\n}\r\n\r\nfunction commitWork(fiber) {\r\n  commitQueue.forEach(c => c.parent && commit(c));\r\n  fiber.done && fiber.done();\r\n  commitQueue = [];\r\n  preCommit = null;\r\n  WIP = null;\r\n}\r\n\r\nfunction commit(fiber) {\r\n  const { op, parentNode, node, ref, hooks } = fiber;\r\n  if (op === NOWORK) ; else if (op === DELETE) {\r\n    hooks && hooks.list.forEach(cleanup);\r\n    cleanupRef(fiber.kids);\r\n    while (isFn(fiber.type)) fiber = fiber.child;\r\n    parentNode.removeChild(fiber.node);\r\n  } else if (isFn(fiber.type)) {\r\n    if (hooks) {\r\n      hooks.layout.forEach(cleanup);\r\n      hooks.layout.forEach(effect);\r\n      hooks.layout = [];\r\n      planWork(() => {\r\n        hooks.effect.forEach(cleanup);\r\n        hooks.effect.forEach(effect);\r\n        hooks.effect = [];\r\n      });\r\n    }\r\n  } else if (op === UPDATE) {\r\n    updateElement(node, fiber.lastProps, fiber.props);\r\n  } else {\r\n    let point = fiber.insertPoint ? fiber.insertPoint.node : null;\r\n    let after = point ? point.nextSibling : parentNode.firstChild;\r\n    if (after === node) return\r\n    if (after === null && node === parentNode.lastChild) return\r\n    parentNode.insertBefore(node, after);\r\n  }\r\n  refer(ref, node);\r\n}\r\n\r\nfunction createFiber(vnode, op) {\r\n  return { ...vnode, op }\r\n}\r\n\r\nconst hashfy = c => {\r\n  const out = {};\r\n  isArr(c)\r\n    ? c.forEach((v, i) =>\r\n        isArr(v)\r\n          ? v.forEach((vi, j) => (out[hs(i, j, vi.key)] = vi))\r\n          : (out[hs(i, null, v.key)] = v)\r\n      )\r\n    : (out[hs(0, null, c.key)] = c);\r\n  return out\r\n};\r\n\r\nfunction refer(ref, dom) {\r\n  if (ref) isFn(ref) ? ref(dom) : (ref.current = dom);\r\n}\r\n\r\nfunction cleanupRef(kids) {\r\n  for (const k in kids) {\r\n    const kid = kids[k];\r\n    refer(kid.ref, null);\r\n    if (kid.kids) cleanupRef(kid.kids);\r\n  }\r\n}\r\n\r\nconst cleanup = e => e[2] && e[2]();\r\n\r\nconst effect = e => {\r\n  const res = e[0]();\r\n  if (isFn(res)) e[2] = res;\r\n};\r\n\r\nconst getCurrentFiber = () => currentFiber || null;\r\n\r\nconst isFn = fn => typeof fn === 'function';\r\n\r\nconst hs = (i, j, k) =>\r\n  k != null && j != null\r\n    ? '.' + i + '.' + k\r\n    : j != null\r\n    ? '.' + i + '.' + j\r\n    : k != null\r\n    ? '.' + k\r\n    : '.' + i;\n\nconst Fre = {\r\n  h,\r\n  Fragment,\r\n  render,\r\n  scheduleWork,\r\n  useState,\r\n  useReducer,\r\n  useEffect,\r\n  useMemo,\r\n  useCallback,\r\n  useRef,\r\n  memo\r\n};\n\nexport default Fre;\nexport { Fragment, h as createElement, h, memo, render, scheduleWork, useCallback, useEffect, useLayout, useLayout as useLayoutEffect, useMemo, useReducer, useRef, useState };\n//# sourceMappingURL=fre.esm.js.map\n"],"names":[],"mappings":";;;EAAA,wBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gIAAA;;;;;;;;;ECAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}